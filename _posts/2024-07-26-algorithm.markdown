---
layout: post
title: 	"알고리즘 개념 6.2"
date: 	2024-07-26 15:52:17 +0900
categories: algorithm
---
# 6장 동적 계획법
## 6.1 
## 6.2 다른 예제
동적 계획법을 이용해 효율적으로 풀 수 있는 문제를 다뤄보자.
### 6.2.1 최장 증가 부분 수열
최장 증가 부분 수열(longest increating subsequence)
- 필요한 것
    - 원소가 n개인 배열에서 일부 원소를 골라내어 만든 부분 수열에서
        - 기존 수열의 순서 변화는 없다.
        - 각 원소가 이전 원소보다 크다는 조건 >> 만족
        - 그 길이가 최대인 것
``` cpp
for( int k=0; k<n; k++){
    length[k]=1;
    for( int i =0; i<k; i++){
        if(array[i]<array[k]){
            length[k]= max(length[k],length[i]+1);
        }
    }
}
// 이 코드는  for를 통해 하나의 배열이 계속 만들어지는 것이다. 그래서 추가적인 내용이 있으면 추가하면 되는 것이다.
//하지만 우리는 처음의 값을 할당해야 한다고 생각하기에 이런 생각이 힘들 수 있다.
// >> 그래서 정답인 배열을 따로 생성한다고 생각해야 겠다.
```
### 6.2.2 격자상의 경로
- 다음 문제는 격자에서 내가 선택할 수 있는 경우의 수는 오른쪽, 아래쪽이다.
- 처음 값을 정하고 가면 될 것 같다.
```cpp
int n;//할당
int array[n-1][n-1]= ??;// 배열 할당함
//총 길이 n+n-1
int sum[n][n];
int sum[0]=array[0][0]
//k는 가로, j는 세로
for(int k=0;k<n;k++){
    for(int j=0;j<n;j++){
        sum[k][j]=max(sum[k-1][j],sum[k][j-1])+array[k][j];
    }
}
// 이 문제는 답으로 들어가는
```
### 6.2.3 짐 싸기 문제
- 짐 싸기(knapsack)는 
    - 여러 물건이 있을 때
    - 특정한 조건을 만족하는 요소를 골라
    - 조합을 구한다.
문제 예시
- [1,3,3,5]에서 *첫 k개*의 요소로 만들 수 있는 합을 구하는 것이다.
- p.89는 더럽게 이해가 안되어 나중에 다시 보도록 ㅠㅠ

```cpp
//기본구조는 재귀
possible(x,k)=possible(x-wk,k-1)or possible(x,k-1)
//기본 값
if(x==0) {possible(x,0)=true;} possible(x,0)=false;
//구조- 이해가 안 됨
possible[0][0]=true;
for(int k=1; k<=n;k++){
    for(int x=0; x<=m; x++){
        if(x-w[k]){
            possible[x][k]=possible[x-w[k]][k-1];
        }
        possible[x][k]=possible[x][k-1];
    }
}
//이전의 방식에서 방향을 다르게 하면 올바르게 작동한다.
possible[0]=true;
for(int k=1; k<=n;k++){
    for(int x=m-w[k];x>=0; x--){
        possible[x+w[k]]=possible[x];
    }
}
```

### 6.2.4 순열을 부분집합으로 바꾸기
동적계획법을 사용하다 보면 순열에 대한 반복을 부분집합에 대한 반복으로 바꿀 수 있는 경우가 있다.
- 순열 반복>> 부분집합 반복
- 이유 : 순열(n!)이 집합(2**n)보다 훨씬 크기 때문이다.
#### 문제 예시
- 최대 하중이 x인 엘리베이터가 있다.
- 1층부터 꼭대기층으로 가려는 사람이 n명
- 사람들을 각 번호 0,1,...,n-1 로 표기
- i번째 사람을 weight[i]라고 표기
- 최소 몇 번 운행해야 할까?
쉬운 방법은 
- o(n!n)이 일반적인 전수조사 방법
동적 계획법을 이용하면
- o(2**n*n)시간의 알고리즘을 만들 수 있다.
- 마지막으로 남은 사람의 최소 무게 집합 last(s)
- 최소 운행 횟수를 나타내는 rides(s)
- 여기서 s는 문제에서 나온 몸무게를 나타낸 배열 weight를 indexing하여 선별했다.

##### 나의 풀이법
- rides는 최소 운행 횟수, 그러니 초깃값 : 1
- if를 이용하여 값이 x를 넘으면 rides에 1을 더한 것을 다음 index에 넣기
- last는 초깃값: 첫번째 인덱스(집합에서 가장 작은 값)
- ?????? last에 새로운 값을 insert하면 어떻게 하지??
    - **도움을 받았습니다.**
    - 이에 대한 해답: 최솟값으로 나타나면 마지막 남은 퍼즐조각이다. 그런데 맞지 않는다면 어쩔 수 없이 새로운 판을 만들어야 한다. 왜냐하면 그 조각이 남은 공간보다 크기 때문이다.
    - 그럼 최소보다 큰 경우엔 엘베를 어떻게 운영하니?
        - 합이 초과하는 경우엔 큰 값을 위한 엘베 하나.
        - 최소를 위한 마지막 엘베를 만들어 다음 사람과 같이 합한다.
```cpp
pair<int,int> best[1<<N];
best[0]={1,0};
//배열 채우기
//낯선 표현: s<(1<<n)
for(int s=1; s<(1<<n);s++){
    //초깃값 : n+1번 운행해야 하는 경우로 설정한다.
    best[s]={n+1,0};
    for(int p=0;p<n;p++){
        if(s&(1<<p)){
            auto option=best[s^(1<<p)];
            if(option.second+weight[p]<=x){
                // p를 기존의 운행에 추가한다.
                option.second+=weight[p];
            }
            else{
                //새로운 운행과 p를 추가한다.
                option.first++;
                option.second =weight[p];
            }
            //이 코드에 대해선 다시 생각해봐야겠다.
            best[s]=min(best[s],option); 
        }
    }
}
```
